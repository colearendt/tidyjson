#' Dive into a specific object "key"
#'
#' JSON can contain nested objects, such as {"key1": {"key2": [1, 2, 3]}}. The
#' function enter_object() can be used to access the array nested under "key1"
#' and "key2". After using enter_object(), all further tidyjson calls happen
#' inside the referenced object (all other JSON data outside the object
#' is discarded). If the object doesn't exist for a given row / index, then that
#' data.frame row will be discarded.
#'
#' This is useful when you want to limit your data to just information found in
#' a specific key. Use the ... to specific a sequence of keys that you want to
#' enter into. Keep in mind that any rows with JSON that do not contain the key
#' will be discarded by this function.
#'
#' Note that the path to filter can either be a comma separated list of strings
#' or unquoted formulas
#'
#' @param x a tbl_json object
#' @param ... path to filter
#' @export
#' @examples
#' c('{"name": "bob", "children": ["sally", "george"]}', '{"name": "anne"}') %>%
#'   spread_values(parent.name = jstring("name")) %>%
#'   enter_object(~children) %>%
#'   gather_array %>%
#'   append_values_string("children")
#'
#' # The path can be nested
#' '{"attributes": { "demographics": {"age": 32, "gender": "male"}}}' %>%
#'   enter_object(~attributes, ~demographics) %>%
#'   spread_values(age = jnumber(~age), gender = jstring(~gender))
#'
#' # You can also use strings rather than formulas
#' '{"attributes": { "demographics": {"age": 32, "gender": "male"}}}' %>%
#'   enter_object("attributes", "demographics") %>%
#'   spread_values(age = jnumber("age"), gender = jstring("gender"))
#'
enter_object <- function(x, ...) {

  if (!is.tbl_json(x)) x <- as.tbl_json(x)

  # Extract json
  json <- attr(x, "JSON")

  # Capture ... as list
  path <- f_list(...)

  # Convert NSE to character strings
  path <- map_if(path, is_formula, compose(as.character, uq))

  # Access path
  json <- json %>% map(path)

  tbl_json(x, json, drop.null.json = TRUE)

}
